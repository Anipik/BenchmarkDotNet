using System;
using System.Diagnostics;
using System.IO;
using System.Runtime.InteropServices;
using System.Text;
using System.Xml;
using System.Xml.Serialization;
using BenchmarkDotNet.Configs;
using BenchmarkDotNet.Diagnosers.DisassemblerDataContracts;
using BenchmarkDotNet.Environments;
using BenchmarkDotNet.Extensions;
using BenchmarkDotNet.Helpers;
using BenchmarkDotNet.Loggers;
using BenchmarkDotNet.Properties;
using BenchmarkDotNet.Toolchains.DotNetCli;
using JetBrains.Annotations;
using RuntimeInformation = BenchmarkDotNet.Portability.RuntimeInformation;

namespace BenchmarkDotNet.Diagnosers
{
    [PublicAPI]
    public class ManagedDotNetDisassembler
    {
        private readonly bool printAsm, printIL, printSource, printPrologAndEpilog;
        private readonly int recursiveDepth;

        [PublicAPI]
        public ManagedDotNetDisassembler(DisassemblyDiagnoserConfig config)
        {
            printIL = config.PrintIL;
            printAsm = config.PrintAsm;
            printSource = config.PrintSource;
            printPrologAndEpilog = config.PrintPrologAndEpilog;
            recursiveDepth = config.RecursiveDepth;
        }

        [PublicAPI]
        public DisassemblyResult Disassemble(DiagnoserActionParameters parameters)
        {
            string resultsPath = Path.GetTempFileName();

            string architectureName = GetArchitectureName(parameters.Process, parameters.BenchmarkCase.Job.Environment.Platform);

            string errors = ProcessHelper.RunAndReadOutput(
                "dotnet",
                BuildArguments(parameters, resultsPath, architectureName));

            if (!string.IsNullOrEmpty(errors))
                parameters.Config.GetCompositeLogger().WriteError(errors);

            try
            {
                using (var stream = new FileStream(resultsPath, FileMode.Open, FileAccess.Read))
                using (var reader = XmlReader.Create(stream))
                {
                    var serializer = new XmlSerializer(typeof(DisassemblyResult));

                    return (DisassemblyResult)serializer.Deserialize(reader);
                }
            }
            finally
            {
                File.Delete(resultsPath);
            }
        }

        private static string GetArchitectureName(Process process, Platform platform)
        {
            switch (platform)
            {
                case Platform.AnyCpu:
                    return GetArchitectureName(process, NativeMethods.Is64Bit(process) ? Platform.X64 : Platform.X86);
                case Platform.X86:
                    return "x86";
                case Platform.X64:
                    return "x64";
                default:
                    throw new NotSupportedException($"Platform {platform} not supported!");
            }
        }

        // if the benchmark requires jitting we use disassembler entry method, if not we use benchmark method name
        private string BuildArguments(DiagnoserActionParameters parameters, string resultsPath, string architectureName)
            => new StringBuilder(200)
                .Append(GetDisassemblerCommand(architectureName)).Append(' ')
                .Append(parameters.Process.Id).Append(' ')
                .Append("BenchmarkDotNet.Autogenerated.Runnable_").Append(parameters.BenchmarkId.Value).Append(' ')
                .Append(DisassemblerConstants.DisassemblerEntryMethodName).Append(' ')
                .Append(printAsm).Append(' ')
                .Append(printIL).Append(' ')
                .Append(printSource).Append(' ')
                .Append(printPrologAndEpilog).Append(' ')
                .Append(recursiveDepth).Append(' ')
                .Append($"\"{resultsPath}\"")
                .ToString();

        private static string GetDisassemblerCommand(string architectureName)
        {
            // for development and tests on CI we want to run the executable from our bin
            if (BenchmarkDotNetInfo.IsDevelop() || BenchmarkDotNetInfo.IsAppveyor())
            {
                if (DotNetCliGenerator.GetSolutionRootDirectory(out var rootDirectory))
                {
                    var configuration = typeof(ManagedDotNetDisassembler).Assembly.IsDebug() == true ? "Debug" : "Release";

                    var path = Path.Combine(rootDirectory.FullName,
                        "src",
                        $"BenchmarkDotNet.Tools.Disassembler.{architectureName}",
                        "bin",
                        configuration,
                        "netcoreapp2.1",
                        $"BenchmarkDotNet.Tools.Disassembler.{architectureName}.dll");

                    return $"\"{path}\"";
                }

                throw new InvalidOperationException("Unable to find root of the Solution");
            }

            return $"disassembler_{architectureName}"; // otherwise our process is just "dotnet"
        }

        // code copied from https://stackoverflow.com/a/33206186/5852046
        private static class NativeMethods
        {
            // see https://msdn.microsoft.com/en-us/library/windows/desktop/ms684139%28v=vs.85%29.aspx
            public static bool Is64Bit(Process process)
            {
                if (Environment.GetEnvironmentVariable("PROCESSOR_ARCHITECTURE") == "x86")
                    return false;

                if (RuntimeInformation.IsWindows())
                {
                    IsWow64Process(process.Handle, out bool isWow64);

                    return !isWow64;
                }

                return RuntimeInformation.Is64BitPlatform(); // todo: find the way to cover all scenarios for .NET Core
            }

            [DllImport("kernel32.dll", SetLastError = true, CallingConvention = CallingConvention.Winapi)]
            [return: MarshalAs(UnmanagedType.Bool)]
            private static extern bool IsWow64Process([In] IntPtr process, [Out] out bool wow64Process);
        }
    }
}